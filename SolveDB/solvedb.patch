diff -ruN postgresql-9.6.0_org/src/backend/nodes/copyfuncs.c postgresql-9.6.0/src/backend/nodes/copyfuncs.c
--- postgresql-9.6.0_org/src/backend/nodes/copyfuncs.c	2016-09-26 22:26:58.000000000 +0200
+++ postgresql-9.6.0/src/backend/nodes/copyfuncs.c	2017-06-02 08:56:05.000000000 +0200
@@ -2536,6 +2536,7 @@
 	COPY_NODE_FIELD(functions);
 	COPY_NODE_FIELD(alias);
 	COPY_NODE_FIELD(coldeflist);
+	COPY_NODE_FIELD(coldef_subquery);
 
 	return newnode;
 }
diff -ruN postgresql-9.6.0_org/src/backend/nodes/equalfuncs.c postgresql-9.6.0/src/backend/nodes/equalfuncs.c
--- postgresql-9.6.0_org/src/backend/nodes/equalfuncs.c	2016-09-26 22:26:58.000000000 +0200
+++ postgresql-9.6.0/src/backend/nodes/equalfuncs.c	2017-06-02 08:56:05.000000000 +0200
@@ -2323,6 +2323,7 @@
 	COMPARE_NODE_FIELD(functions);
 	COMPARE_NODE_FIELD(alias);
 	COMPARE_NODE_FIELD(coldeflist);
+	COMPARE_NODE_FIELD(coldef_subquery);
 
 	return true;
 }
diff -ruN postgresql-9.6.0_org/src/backend/nodes/outfuncs.c postgresql-9.6.0/src/backend/nodes/outfuncs.c
--- postgresql-9.6.0_org/src/backend/nodes/outfuncs.c	2016-09-26 22:26:58.000000000 +0200
+++ postgresql-9.6.0/src/backend/nodes/outfuncs.c	2017-06-02 08:56:05.000000000 +0200
@@ -3133,6 +3133,7 @@
 	WRITE_NODE_FIELD(functions);
 	WRITE_NODE_FIELD(alias);
 	WRITE_NODE_FIELD(coldeflist);
+	WRITE_NODE_FIELD(coldef_subquery);
 }
 
 static void
diff -ruN postgresql-9.6.0_org/src/backend/parser/gram.y postgresql-9.6.0/src/backend/parser/gram.y
--- postgresql-9.6.0_org/src/backend/parser/gram.y	2016-09-26 22:26:58.000000000 +0200
+++ postgresql-9.6.0/src/backend/parser/gram.y	2017-11-10 12:47:30.000000000 +0100
@@ -132,6 +132,20 @@
 #define parser_yyerror(msg)  scanner_yyerror(msg, yyscanner)
 #define parser_errposition(pos)  scanner_errposition(pos, yyscanner)
 
+/* SolveDB BEGIN */
+
+#define parser_str_from_scanbuf(loc, len) scanner_str_from_scanbuf(loc, len, yyscanner)
+
+/* Make the sl_problem specification of the problem, as a typecasted RowExpr */
+static Node *makeSolveProblem(char *input_sql, char *input_alias, List *cols_unknown, List *inlines, List *ctes, char obj_dir, char *obj_sql, List *ctr_sql, int location);
+
+/* Make the  SOLVESELECT function call */			       
+static FuncCall *makeSolveCall(Node * problem, char *solver_name, char *method_name, List *par_val_pairs, int location);
+			       
+static TypeName *SystemArrayTypeName(char *name, int numDim);
+
+/* SolveDB END */
+
 static void base_yyerror(YYLTYPE *yylloc, core_yyscan_t yyscanner,
 						 const char *msg);
 static Node *makeColumnRef(char *colname, List *indirection,
@@ -266,6 +280,7 @@
 		DropOwnedStmt ReassignOwnedStmt
 		AlterTSConfigurationStmt AlterTSDictionaryStmt
 		CreateMatViewStmt RefreshMatViewStmt CreateAmStmt
+		SolveStmt
 
 %type <node>	select_no_parens select_with_parens select_clause
 				simple_select values_clause
@@ -540,6 +555,17 @@
 %type <str>		opt_existing_window_name
 %type <boolean> opt_if_not_exists
 
+
+/* SolveDB BEGIN */
+
+%type <list>	solve_problem opt_solve_maxmin_clause opt_solve_colid_list solve_colid_list opt_solve_subto_clause solve_selectstmt_list opt_solver_params solver_params opt_solve_cte_clause opt_solve_inline_clause solve_cte_clause_exp_list solve_cte_clause_exp
+%type <chr>		solve_maxminimize
+%type <node>	solve_selectstmt
+%type <str>		opt_solvermethod
+%type <defelt>	solver_param
+
+/* SolveDB END */
+
 /*
  * Non-keyword token types.  These are hard-wired into the "flex" lexer.
  * They must be listed first so that their numeric codes do not depend on
@@ -606,7 +632,7 @@
 	LEADING LEAKPROOF LEAST LEFT LEVEL LIKE LIMIT LISTEN LOAD LOCAL
 	LOCALTIME LOCALTIMESTAMP LOCATION LOCK_P LOCKED LOGGED
 
-	MAPPING MATCH MATERIALIZED MAXVALUE METHOD MINUTE_P MINVALUE MODE MONTH_P MOVE
+	MAPPING MATCH MATERIALIZED MAXIMIZE MAXVALUE METHOD MINIMIZE MINUTE_P MINVALUE MODE MODELEVAL MONTH_P MOVE
 
 	NAME_P NAMES NATIONAL NATURAL NCHAR NEXT NO NONE
 	NOT NOTHING NOTIFY NOTNULL NOWAIT NULL_P NULLIF
@@ -627,9 +653,9 @@
 	ROW ROWS RULE
 
 	SAVEPOINT SCHEMA SCROLL SEARCH SECOND_P SECURITY SELECT SEQUENCE SEQUENCES
-	SERIALIZABLE SERVER SESSION SESSION_USER SET SETS SETOF SHARE SHOW
-	SIMILAR SIMPLE SKIP SMALLINT SNAPSHOT SOME SQL_P STABLE STANDALONE_P START
-	STATEMENT STATISTICS STDIN STDOUT STORAGE STRICT_P STRIP_P SUBSTRING
+	SERIALIZABLE SERVER SESSION SESSION_USER SET SETS SETOF SHARE SHOW	
+	SIMILAR SIMPLE SKIP SMALLINT SNAPSHOT SOLVEMODEL SOLVESELECT SOME SQL_P STABLE STANDALONE_P START
+	STATEMENT STATISTICS STDIN STDOUT STORAGE STRICT_P STRIP_P SUBJECTTO SUBSTRING
 	SYMMETRIC SYSID SYSTEM_P
 
 	TABLE TABLES TABLESAMPLE TABLESPACE TEMP TEMPLATE TEMPORARY TEXT_P THEN
@@ -672,7 +698,8 @@
 %left		AND
 %right		NOT
 %nonassoc	IS ISNULL NOTNULL	/* IS sets precedence for IS NULL, etc */
-%nonassoc	'<' '>' '=' LESS_EQUALS GREATER_EQUALS NOT_EQUALS
+/* SolveDB fix: Introduce the associativity to the comparison operators */
+%left		'<' '>' '=' LESS_EQUALS GREATER_EQUALS NOT_EQUALS
 %nonassoc	BETWEEN IN_P LIKE ILIKE SIMILAR NOT_LA
 %nonassoc	ESCAPE			/* ESCAPE must be just above LIKE/ILIKE/SIMILAR */
 %left		POSTFIXOP		/* dummy for postfix Op rules */
@@ -752,6 +779,123 @@
 					else
 						$$ = NIL;
 				}
+/* SOLVEDB: MODELEVAL Support */
+			| MODELEVAL '(' SelectStmt ')' IN_P '(' SelectStmt ')'
+				{
+					/* This will get rewritten into two statements: 
+					
+					SELECT sl_create_execute_view((SELECT m FROM t), 'SELECT 1', 'tmppp');
+
+					WITH res AS (SELECT * FROM tmppp)
+					SELECT res.* FROM res, sl_drop_view('tmppp');						
+
+					*/
+
+					/* Stmt1 vars */
+					SelectStmt *s1;
+					char *query_sql;
+					FuncCall * fc1;
+					ResTarget *rt1;
+					SubLink *n1 = makeNode(SubLink);
+					
+					/* Stmt2 vars */
+					SelectStmt *s2, *ss2;
+					ResTarget *srt2, *rt2;
+					ColumnRef *cr2;
+					FuncCall * fc2;
+					CommonTableExpr *c2 = makeNode(CommonTableExpr);
+					WithClause *w2 = makeNode(WithClause);
+	   				RangeFunction *r2;
+					
+					/* Build statement 1 */ 
+
+					/* Copy the actual query */
+					query_sql = parser_str_from_scanbuf(@2+1, @4-@2-1);
+					Assert(query_sql != NULL && query_sql[0] != '\0');	 /* This cannot happen */
+
+					n1->subLinkType = EXPR_SUBLINK;
+					n1->subLinkId = 0;
+					n1->testexpr = NULL;
+					n1->operName = NIL;
+					n1->subselect = $7;
+					n1->location = @7;
+
+					fc1 = makeFuncCall(
+						list_make1(makeString("sl_create_execute_view")),
+						list_make3(
+						     /* First argument: the actual sub-select */
+					             n1,
+						     /* Second argument: the user query as text */
+						     makeStringConst(query_sql, @3),
+						     /* Third argument: the temp table name */	
+			    	 	             makeStringConst("tmp_model_eval_view", @3)
+						),
+						@3);
+					  					
+
+					rt1 = makeNode(ResTarget);
+					rt1->name = NULL;
+					rt1->indirection = NIL;
+					rt1->val = (Node *)fc1;
+					rt1->location = -1;				
+
+					s1 = makeNode(SelectStmt);
+					s1->targetList = list_make1(rt1);
+
+					/* Build statement 2 */ 
+
+					cr2 = makeNode(ColumnRef);
+					cr2->fields = list_make1(makeNode(A_Star));
+					cr2->location = -1;
+
+					srt2 = makeNode(ResTarget);
+					srt2->name = NULL;
+					srt2->indirection = NIL;
+					srt2->val = (Node *)cr2;
+					srt2->location = -1;				
+
+					ss2 = makeNode(SelectStmt);
+					ss2->targetList = list_make1(srt2);
+					ss2->fromClause = list_make1(makeRangeVar(NULL, "tmp_model_eval_view", -1));
+
+					c2->ctename = "res";
+					c2->aliascolnames = NIL;
+					c2->ctequery = (Node *)ss2;
+					c2->location = -1;
+                                                          					
+					w2->ctes = list_make1(c2);
+					w2->location = -1;					
+
+					fc2 = makeFuncCall(
+						list_make1(makeString("sl_drop_view")),
+						list_make1(
+						     /* Third argument: the temp table name */	
+			    	 	             makeStringConst("tmp_model_eval_view", @3)
+						),
+						@3);
+
+	   				r2 = makeNode(RangeFunction);
+					r2->lateral = false;
+					r2->ordinality = false;
+					r2->is_rowsfrom = false;
+					r2->alias = NULL;
+					r2->coldeflist = NULL;
+					r2->coldef_subquery = NULL;
+					r2->functions = list_make1(list_make2(fc2, NIL));	  /* On error, stops at the solver's name location */
+                                                                  
+					rt2 = makeNode(ResTarget);
+					rt2->name = NULL;
+					rt2->indirection = NULL;
+					rt2->val = (Node *)makeColumnRef("res", list_make1(makeNode(A_Star)), @3, yyscanner);
+					rt2->location = -1;									
+                                                                                                     
+					s2 = makeNode(SelectStmt);
+					s2->withClause = w2;
+					s2->targetList = list_make1(rt2);
+					s2->fromClause = list_make2(makeRangeVar(NULL, "res", -1), r2);
+
+					$$ = list_make2(s1, s2);
+				}
 		;
 
 stmt :
@@ -884,6 +1028,191 @@
 				{ $$ = NULL; }
 		;
 
+		
+/*****************************************************************************
+ *
+ *		SOLVESELECT [<column_id> [, ...] IN ]  ( SelectStmt ) [ AS name ]
+ *      [INLINE     [<column_id> [, ...] IN ]  ( SelectStmt )   AS name [, ...] ]
+ *		[WITH       [<column_id> [, ...] IN ]  ( SelectStmt )   AS name [, ...] ]		
+ *		[MAXIMIZE | MINIMIZE ( SelectStmt ) ]
+ *		[SUBJECTTO [ (SelectStmt) [, ...] ] 
+ * 		[USING solver [.method] ( [param [:= param_value], [,...] ])
+ *
+ *	 	WHERE
+ *                - param_value:  [ numeric | ( SelectStmt ) ]
+ *
+ *****************************************************************************/
+
+SolveStmt: SOLVESELECT solve_problem 
+		   USING name opt_solvermethod opt_solver_params
+		   		{
+		   				RangeFunction *r;
+		   				ColumnRef *cr;
+		   				ResTarget *rt;
+		   				SelectStmt *n;		   				
+		   				Node  * problem = list_nth($2, 0); 
+		   				Node  * input_rel = list_nth($2, 1);
+		   				char  * input_alias = list_nth($2, 2);
+		   				Alias * a;
+		   				
+		   				/* Build the alias for the input relation */
+						a = makeNode(Alias);
+						a->aliasname = input_alias;	   				
+		   				 
+		   				
+		   				/* Build the range function, generating output */		   				
+		   				r = makeNode(RangeFunction);
+						r->lateral = false;
+						r->ordinality = false;
+						r->is_rowsfrom = false;
+						r->alias = a;
+						r->coldeflist = NULL;
+						r->coldef_subquery = input_rel;
+						r->functions = list_make1(list_make2( 
+	 						makeSolveCall(
+	 								  problem,
+								      $4, 	  /* A name of the solver */
+								      $5, 	  /* A name of the solve method */
+								      $6, 	  /* A solver method parameters */
+								      @4), NIL));	  /* On error, stops at the solver's name location */
+
+						cr = makeNode(ColumnRef);
+						cr->fields = list_make1(makeNode(A_Star));
+						cr->location = -1;
+
+						rt = makeNode(ResTarget);
+						rt->name = NULL;
+						rt->indirection = NIL;
+						rt->val = (Node *)cr;
+						rt->location = -1;				
+
+						n = makeNode(SelectStmt);
+						n->targetList = list_make1(rt);
+						n->fromClause = list_make1(r);
+
+						$$ = (Node *) n;
+		   		}
+		;
+
+/* This rule is for problem specification. Returns  (1) sl_problem specification, (2) input query, and (3) input query alias  */
+solve_problem:	opt_solve_colid_list '(' SelectStmt ')' opt_solve_inline_clause opt_solve_cte_clause opt_solve_maxmin_clause opt_solve_subto_clause
+				{
+						Node * problem;
+						char *input_sql;
+						char *input_alias =  list_nth($1, 1) != NULL ? list_nth($1, 1) : "input_relation";
+						List *mm_clause = $7;
+				
+						/* Read an input SQL as string */
+						input_sql = parser_str_from_scanbuf(@2+1, @4-@2-1);
+						Assert(input_sql != NULL && input_sql[0] != '\0');	 /* This cannot happen */
+						
+						/* Build the problem */
+						problem = makeSolveProblem(input_sql,  /* Input SQL */
+	 								  input_alias,/* Alias of the input */
+								      list_nth($1, 0),    /* A list of unknown columns */
+								      $5,		  /* Inline list */	
+									  $6,		  /* CTEs list */
+	 							      mm_clause != NULL ? ((char ) (long) (void *) list_nth(mm_clause, 0)) : 'u',  /* Objective direction */
+								      mm_clause != NULL ? (char *) list_nth(mm_clause, 1) : NULL,       /* Objective SQL */
+							 	      $8, 	  /* A list of subject to SQL statements */
+								      @1);
+
+						$$ = list_make3(problem, $3, input_alias);
+				}
+		;
+
+opt_solve_colid_list:		solve_colid_list IN_P name AS		{ $$ = list_make2($1, $3); }
+				| solve_colid_list IN_P			{ $$ = list_make2($1, NULL); }
+				| name '(' solve_colid_list ')' AS 	{ $$ = list_make2($3, $1); }
+				| name AS 				{ $$ = list_make2(NULL, $1); }
+				| /* Empty */ 				{ $$ = list_make2(NULL, NULL); }
+		;
+
+solve_colid_list: 			ColId					{ $$ = list_make1(makeStringConst($1,  @1));	}
+				| 			'*'						{ $$ = list_make1(makeStringConst("*", @1)); } 
+				| ColId ',' solve_colid_list		{ $$ = lappend($3, makeStringConst($1, @1)); 	}
+		;
+				
+
+opt_solve_inline_clause:	INLINE_P solve_cte_clause_exp_list { $$ = $2;  }
+                | /* Empty */	      					   	   { $$ = NIL; }
+        ;
+
+opt_solve_cte_clause:       WITH solve_cte_clause_exp_list { $$ = $2;  }
+                | /* Empty */	      					   { $$ = NIL; }
+        ;
+
+solve_cte_clause_exp_list:  solve_cte_clause_exp   { $$ = list_make1($1); }
+				|			solve_cte_clause_exp ',' solve_cte_clause_exp_list { $$ = lcons($1, $3); }
+		;
+				
+solve_cte_clause_exp:	opt_solve_colid_list '(' SelectStmt ')'
+					{
+						char * sql = parser_str_from_scanbuf(@2+1, @4-@2-1);
+						/* This cannot happen */
+						Assert(sql != NULL && sql[0] != '\0');
+						$$ = list_make3(list_nth($1, 0), makeStringConst(sql, @3), list_nth($1, 1)); 
+					}
+		;
+
+opt_solve_maxmin_clause: 	solve_maxminimize '(' SelectStmt ')'
+				{
+					char   obj_dir = $1;
+					char * obj_sql;
+
+					obj_sql = parser_str_from_scanbuf(@2+1, @4-@2-1);
+					/* This cannot happen */
+					Assert(obj_sql != NULL && obj_sql[0] != '\0'); 
+					$$ = list_make2((void *) (long) obj_dir, obj_sql);	/* We don't put into a constant as this is short-lived */
+				}
+				| /* Empty */ { $$ = NULL; }
+		;
+
+solve_maxminimize: 	        MAXIMIZE	{ $$ = 'a'; } 
+				| 		    MINIMIZE	{ $$ = 'i'; }
+				| /* Empty */ 	{ $$ = 'u'; } /* Undefined */
+		;
+
+opt_solve_subto_clause:		SUBJECTTO solve_selectstmt_list			{ $$ = $2; }
+				| /* Empty */   									{ $$ = NIL; } 
+		;
+
+solve_selectstmt_list:		solve_selectstmt 							{ $$ = list_make1($1); } 
+				| 			solve_selectstmt ',' solve_selectstmt_list	{ $$ = lcons($1, $3); }
+		;
+
+solve_selectstmt:		'(' SelectStmt ')'
+				{
+	                       		char * sql = parser_str_from_scanbuf(@1+1, @3-@1-1);
+								/* This cannot happen */
+								Assert(sql != NULL && sql[0] != '\0'); 
+								$$ = makeStringConst(sql, @2);
+				}
+		;
+
+opt_solvermethod:		'.' name	{ $$ = $2;   };
+				| /* Empty */		{ $$ = NULL; };
+		;
+
+opt_solver_params:		'(' solver_params ')' 	{ $$ = $2; }
+				| /* Empty */ 	      			{ $$ = NIL; }
+		;
+
+solver_params:  		solver_param				{ $$ = list_make1($1);  }
+				| solver_param ',' solver_params	{ $$ = lappend($3, $1);	}
+				| /* Empty */ 	      				{ $$ = NIL; }
+	    ;
+
+solver_param:			param_name 				{ $$ = makeDefElem($1, NULL); }
+				| 		param_name COLON_EQUALS a_expr
+				{
+					$$ = makeDefElem($1, (Node *) $3);
+				}
+		;
+
+
+
+
 /*****************************************************************************
  *
  * Create a new Postgres DBMS role
@@ -10151,6 +10480,7 @@
 					$$ = (Node *)n;
 				}
 			| values_clause							{ $$ = $1; }
+			| SolveStmt
 			| TABLE relation_expr
 				{
 					/* same as SELECT * FROM relation_expr */
@@ -12197,6 +12527,10 @@
 				  g->location = @1;
 				  $$ = (Node *)g;
 			  }
+			| '(' SOLVEMODEL solve_problem ')' 
+			  {
+			  	  $$ = list_nth($3, 0);	
+			  } 
 		;
 
 func_application: func_name '(' ')'
@@ -14150,6 +14484,9 @@
 			| LIMIT
 			| LOCALTIME
 			| LOCALTIMESTAMP
+			| MAXIMIZE
+			| MINIMIZE
+			| MODELEVAL
 			| NOT
 			| NULL_P
 			| OFFSET
@@ -14163,7 +14500,10 @@
 			| RETURNING
 			| SELECT
 			| SESSION_USER
+			| SOLVEMODEL
+			| SOLVESELECT
 			| SOME
+			| SUBJECTTO
 			| SYMMETRIC
 			| TABLE
 			| THEN
@@ -14992,6 +15332,153 @@
 	return (Node *) s;
 }
 
+/* Create and populate the sl_problem type */
+static Node *makeSolveProblem(char *input_sql, char *input_alias, List *cols_unknown, List *inlines, List *ctes, char obj_dir, char *obj_sql, List *ctr_sql, int location)
+{
+	ListCell *c;
+	RowExpr  *ap; /* A record type to define a problem */
+	List	 *pinlines;  /* Inlines */
+	List	 *pctes;  	 /* CTEs */
+	TypeName *ctetn;  	 /* The type name sl_cte_relation[] */
+	
+	/* 2017-08-06 Inline support */
+	pinlines = NIL;
+	foreach(c, inlines)
+	{
+		List * e = (List *) lfirst(c);
+		
+		RowExpr * ce = makeNode(RowExpr);
+		ce->row_typeid = InvalidOid;	/* not analyzed yet */
+		ce->colnames = NIL;	/* to be filled in during analysis */
+		ce->location = location;
+		ce->args = NIL;
+		ce->args = lappend(ce->args, list_nth(e, 1));
+		ce->args = lappend(ce->args, makeStringConst(list_nth(e, 2), location));	
+		ce->args = lappend(ce->args, makeTypeCast(makeAArrayExpr(list_nth(e, 0), location), SystemArrayTypeName("text", 1), location));
+			
+		pinlines = lappend(pinlines,  makeTypeCast((Node *) ce, makeTypeNameFromNameList(list_make1(makeString("sl_cte_relation"))), location));
+	}
+	
+	/* 2016-11-01 CTE support */
+	/* Build CTE expressions */
+	pctes = NIL;
+	foreach(c, ctes)
+	{
+		List * e = (List *) lfirst(c);
+		
+		RowExpr * ce = makeNode(RowExpr);
+		ce->row_typeid = InvalidOid;	/* not analyzed yet */
+		ce->colnames = NIL;	/* to be filled in during analysis */
+		ce->location = location;
+		ce->args = NIL;
+		ce->args = lappend(ce->args, list_nth(e, 1));
+		ce->args = lappend(ce->args, makeStringConst(list_nth(e, 2), location));	
+		ce->args = lappend(ce->args, makeTypeCast(makeAArrayExpr(list_nth(e, 0), location), SystemArrayTypeName("text", 1), location));
+			
+		pctes = lappend(pctes,  makeTypeCast((Node *) ce, makeTypeNameFromNameList(list_make1(makeString("sl_cte_relation"))), location));
+	}
+	/* Build CTE type name */
+	ctetn = makeTypeNameFromNameList(list_make1(makeString("sl_cte_relation")));
+	ctetn->arrayBounds = lappend(ctetn->arrayBounds, makeInteger(-1));
+        
+	/* Build a problem argument */	
+	ap = makeNode(RowExpr);
+	ap->row_typeid = InvalidOid;	/* not analyzed yet */
+	ap->colnames = NIL;	/* to be filled in during analysis */
+	ap->location = location;
+	ap->args = NIL;
+	ap->args = lappend(ap->args, makeStringConst(input_sql, location));	  /* Input SQL statement */
+	ap->args = lappend(ap->args, input_alias != NULL ? makeStringConst(input_alias, location) : makeNullAConst(location));     /* Alias of the input */
+	ap->args = lappend(ap->args, makeTypeCast(makeAArrayExpr(cols_unknown, location), SystemArrayTypeName("text", 1), location));
+	ap->args = lappend(ap->args, makeStringConst(obj_dir=='a'?"maximize": 
+						     obj_dir=='i'?"minimize": "undefined", location));
+	ap->args = lappend(ap->args, obj_sql != NULL ? makeStringConst(obj_sql, location) : makeNullAConst(location));
+	ap->args = lappend(ap->args, makeTypeCast(makeAArrayExpr(ctr_sql, location), SystemArrayTypeName("text", 1), location));	
+	ap->args = lappend(ap->args, makeTypeCast(makeAArrayExpr(pinlines, location), ctetn, location));
+	ap->args = lappend(ap->args, makeTypeCast(makeAArrayExpr(pctes, location), ctetn, location));
+	/* makeNullAConst(location)*/
+	
+
+	/* Build an argument for a solve call  */
+	return makeTypeCast((Node *) ap, makeTypeNameFromNameList(list_make1(makeString("sl_problem"))), location);
+
+}
+
+/* 
+ * Create and populate a function call based on SolveSelect.
+ */
+static FuncCall *makeSolveCall(Node * problem, char *solver_name, char *method_name, List *par_val_pairs, int location)
+{
+	ListCell *c;
+	FuncCall *n;	
+	RowExpr  *aq; /* A record type to define solve query */
+ 	List	 *spars; /* Solver parameters */
+	
+
+
+	/* Build solver parameters */
+	spars = NIL;
+	foreach(c, par_val_pairs)
+	{
+		DefElem * e = (DefElem *) lfirst(c);
+		spars = lappend(spars, makeAArrayExpr(
+					list_make2(makeStringConst(e->defname, location), 
+						   e->arg != NULL ? makeTypeCast(e->arg, SystemTypeName("text"), location) : makeNullAConst(location)),
+						       location));
+	}	
+
+	/* Build an argument for a solve call  */
+	aq = makeNode(RowExpr);
+	aq->row_typeid = InvalidOid;	/* not analyzed yet */
+	aq->colnames = NIL;	/* to be filled in during analysis */
+	aq->location = location;
+	aq->args = NIL;
+    aq->args = lappend(aq->args, problem);
+    aq->args = lappend(aq->args, makeStringConst(solver_name, location));
+	aq->args = lappend(aq->args, method_name == NULL ? makeNullAConst(location) : makeStringConst(method_name, location));
+
+	/* Buld the function call */
+	n = makeNode(FuncCall);
+	n->funcname = list_make1(makeString("sl_solve"));		/* An unqualified name of "sl_solve" method. We expect it to be residient in PG extension SolverAPI */
+	n->args = list_make2(
+		     /* First argument: sl_solve_query */
+	             makeTypeCast((Node *) aq, 
+			                  makeTypeNameFromNameList(list_make1(makeString("sl_solve_query"))),
+			                  location),
+		     /* First argument: text[][] */
+		     makeTypeCast(spars != NULL ? makeAArrayExpr(spars, location) : makeNullAConst(location), 
+						      SystemArrayTypeName("text", 2), location)
+			     ); 
+	n->agg_order = NIL;
+	n->agg_star = FALSE;
+	n->agg_distinct = FALSE;
+	n->func_variadic = FALSE;
+	n->over = NULL;
+	n->location = location; 
+
+	return n;
+}
+
+/* SystemArrayTypeName()
+ * Build a properly-qualified reference to an array of a built-in type.
+ *
+ * numDim - a number of array dimensions
+ */
+TypeName *
+SystemArrayTypeName(char *name, int numDim)
+{
+	TypeName * tn = SystemTypeName(name);
+	int i;
+
+	for (i=0; i< numDim; i++)
+		tn->arrayBounds = lappend(tn->arrayBounds, makeInteger(-1));
+
+	return tn;
+}
+
+
+
+
 /* parser_init()
  * Initialize to parse one query string
  */
diff -ruN postgresql-9.6.0_org/src/backend/parser/scan.l postgresql-9.6.0/src/backend/parser/scan.l
--- postgresql-9.6.0_org/src/backend/parser/scan.l	2016-09-26 22:26:58.000000000 +0200
+++ postgresql-9.6.0/src/backend/parser/scan.l	2017-06-02 08:56:05.000000000 +0200
@@ -1026,6 +1026,32 @@
 #undef yyleng
 #define yyleng	(((struct yyguts_t *) yyscanner)->yyleng_r)
 
+/*
+ * scanner_str_from_scanbuf
+ *		Returns a pointer to a sub-string in scanbuf, given the "offset from" and "offset to" of a sub-string .
+ *
+ * Note that this can only be used for messages emitted during raw parsing
+ * (essentially, scan.l and gram.y), since it requires the yyscanner struct
+ * to still be available.
+ */
+char * scanner_str_from_scanbuf(int loc, int len, core_yyscan_t yyscanner)
+{
+	char * str; 
+
+	if (loc < 0 || len < 0)
+		return pstrdup("");
+	
+	if (loc + len >= yyextra->scanbuflen)
+		return pstrdup("");
+
+	/* Copy the substring */
+	str = (char *) palloc(len + 1);
+	memcpy(str, yyextra->scanbuf + loc, len);
+	str[len] = '\0';
+
+	return str;
+}
+
 
 /*
  * scanner_errposition
diff -ruN postgresql-9.6.0_org/src/include/nodes/parsenodes.h postgresql-9.6.0/src/include/nodes/parsenodes.h
--- postgresql-9.6.0_org/src/include/nodes/parsenodes.h	2016-09-26 22:26:58.000000000 +0200
+++ postgresql-9.6.0/src/include/nodes/parsenodes.h	2017-06-02 08:56:05.000000000 +0200
@@ -543,6 +543,7 @@
 	Alias	   *alias;			/* table alias & optional column aliases */
 	List	   *coldeflist;		/* list of ColumnDef nodes to describe result
 								 * of function returning RECORD */
+	Node	   *coldef_subquery;/* the subquery to override description of a function, returning RECORD  */
 } RangeFunction;
 
 /*
diff -ruN postgresql-9.6.0_org/src/include/parser/kwlist.h postgresql-9.6.0/src/include/parser/kwlist.h
--- postgresql-9.6.0_org/src/include/parser/kwlist.h	2016-09-26 22:26:58.000000000 +0200
+++ postgresql-9.6.0/src/include/parser/kwlist.h	2017-11-09 14:29:10.000000000 +0100
@@ -239,11 +239,14 @@
 PG_KEYWORD("mapping", MAPPING, UNRESERVED_KEYWORD)
 PG_KEYWORD("match", MATCH, UNRESERVED_KEYWORD)
 PG_KEYWORD("materialized", MATERIALIZED, UNRESERVED_KEYWORD)
+PG_KEYWORD("maximize", MAXIMIZE, RESERVED_KEYWORD)
 PG_KEYWORD("maxvalue", MAXVALUE, UNRESERVED_KEYWORD)
 PG_KEYWORD("method", METHOD, UNRESERVED_KEYWORD)
+PG_KEYWORD("minimize", MINIMIZE, RESERVED_KEYWORD)
 PG_KEYWORD("minute", MINUTE_P, UNRESERVED_KEYWORD)
 PG_KEYWORD("minvalue", MINVALUE, UNRESERVED_KEYWORD)
 PG_KEYWORD("mode", MODE, UNRESERVED_KEYWORD)
+PG_KEYWORD("modeleval", MODELEVAL, RESERVED_KEYWORD)
 PG_KEYWORD("month", MONTH_P, UNRESERVED_KEYWORD)
 PG_KEYWORD("move", MOVE, UNRESERVED_KEYWORD)
 PG_KEYWORD("name", NAME_P, UNRESERVED_KEYWORD)
@@ -357,6 +360,8 @@
 PG_KEYWORD("skip", SKIP, UNRESERVED_KEYWORD)
 PG_KEYWORD("smallint", SMALLINT, COL_NAME_KEYWORD)
 PG_KEYWORD("snapshot", SNAPSHOT, UNRESERVED_KEYWORD)
+PG_KEYWORD("solvemodel", SOLVEMODEL, RESERVED_KEYWORD)
+PG_KEYWORD("solveselect", SOLVESELECT, RESERVED_KEYWORD)
 PG_KEYWORD("some", SOME, RESERVED_KEYWORD)
 PG_KEYWORD("sql", SQL_P, UNRESERVED_KEYWORD)
 PG_KEYWORD("stable", STABLE, UNRESERVED_KEYWORD)
@@ -369,6 +374,7 @@
 PG_KEYWORD("storage", STORAGE, UNRESERVED_KEYWORD)
 PG_KEYWORD("strict", STRICT_P, UNRESERVED_KEYWORD)
 PG_KEYWORD("strip", STRIP_P, UNRESERVED_KEYWORD)
+PG_KEYWORD("subjectto", SUBJECTTO, RESERVED_KEYWORD)
 PG_KEYWORD("substring", SUBSTRING, COL_NAME_KEYWORD)
 PG_KEYWORD("symmetric", SYMMETRIC, RESERVED_KEYWORD)
 PG_KEYWORD("sysid", SYSID, UNRESERVED_KEYWORD)
diff -ruN postgresql-9.6.0_org/src/include/parser/scanner.h postgresql-9.6.0/src/include/parser/scanner.h
--- postgresql-9.6.0_org/src/include/parser/scanner.h	2016-09-26 22:26:58.000000000 +0200
+++ postgresql-9.6.0/src/include/parser/scanner.h	2017-06-02 08:56:05.000000000 +0200
@@ -127,4 +127,8 @@
 extern int	scanner_errposition(int location, core_yyscan_t yyscanner);
 extern void scanner_yyerror(const char *message, core_yyscan_t yyscanner) pg_attribute_noreturn();
 
+/* Added to support of SOLVESELECT */
+extern char *	scanner_str_from_scanbuf(int loc, int len, core_yyscan_t yyscanner);
+
+
 #endif   /* SCANNER_H */
